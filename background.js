/**
 * @file background.js
 * @description Ponto de entrada principal da extensão, gere eventos e a fila de processamento.
 */

import Logger from './logger.js';
import { settings, loadSettings, updateSettings } from './settings-manager.js';
import { processTabQueue } from './grouping-logic.js';
import { initializeContextMenus, updateContextMenus } from './context-menu-manager.js';
import { recentlyCreatedAutomaticGroups, pendingClassificationGroups, injectionFailureMap } from './app-state.js';

// --- Constantes e Variáveis de Estado ---

const QUEUE_DELAY = 500;
const TITLE_UPDATE_DEBOUNCE = 250; // ms
const CLASSIFICATION_TIMEOUT = 500; // ms

let tabProcessingQueue = new Set();
let queueTimeout = null;
let tabGroupMap = new Map();
let debouncedTitleUpdaters = new Map();
let groupActivity = new Map();
let collapseInterval = null;
let ungroupInterval = null;
let singleTabGroupTimestamps = new Map();

// --- Lógica de Processamento e Gestão de Eventos ---

function scheduleQueueProcessing() {
    Logger.debug('scheduleQueueProcessing', 'Agendamento de processamento da fila.');
    if (queueTimeout) clearTimeout(queueTimeout);
    queueTimeout = setTimeout(async () => {
        const tabsToProcess = Array.from(tabProcessingQueue);
        tabProcessingQueue.clear();
        Logger.info('Queue', `A processar ${tabsToProcess.length} abas.`, tabsToProcess);
        await processTabQueue(tabsToProcess);
    }, QUEUE_DELAY);
}

function handleTabUpdated(tabId, changeInfo, tab) {
    Logger.debug('handleTabUpdated', `Aba ${tabId} atualizada. Status: ${changeInfo.status}`, { changeInfo, tab });
    if (changeInfo.groupId !== undefined) {
        const oldGroupId = tabGroupMap.get(tabId);
        if (oldGroupId) {
            scheduleTitleUpdate(oldGroupId);
        }
        scheduleTitleUpdate(changeInfo.groupId);
        tabGroupMap.set(tabId, changeInfo.groupId);
    }

    if (settings.autoGroupingEnabled && changeInfo.status === 'complete' && tab.url) {
        injectionFailureMap.delete(tabId);
        tabProcessingQueue.add(tabId);
        scheduleQueueProcessing();
    }
}

function handleTabRemoved(tabId, removeInfo) {
    Logger.debug('handleTabRemoved', `Aba ${tabId} removida.`, { removeInfo });
    const oldGroupId = tabGroupMap.get(tabId);
    if (oldGroupId) {
        scheduleTitleUpdate(oldGroupId);
    }
    tabGroupMap.delete(tabId);
    injectionFailureMap.delete(tabId);
}

function toggleListeners(enable) {
    const hasUpdatedListener = browser.tabs.onUpdated.hasListener(handleTabUpdated);
    const hasRemovedListener = browser.tabs.onRemoved.hasListener(handleTabRemoved);

    if (enable) {
        if (!hasUpdatedListener) {
            browser.tabs.onUpdated.addListener(handleTabUpdated, { properties: ["status", "groupId"] });
        }
        if (!hasRemovedListener) {
            browser.tabs.onRemoved.addListener(handleTabRemoved);
        }
    } else {
        if (hasUpdatedListener) {
            browser.tabs.onUpdated.removeListener(handleTabUpdated);
        }
        if (hasRemovedListener) {
            browser.tabs.onRemoved.removeListener(handleTabRemoved);
        }
    }
}

// --- Lógica de Comportamento dos Grupos (Timers) ---

function updateAutoCollapseTimer() {
    Logger.debug('Timers', `Timer de auto-collapse ${settings.autoCollapseTimeout > 0 ? `ativado (${settings.autoCollapseTimeout}s)`: 'desativado'}.`);
    if (collapseInterval) clearInterval(collapseInterval);
    collapseInterval = null;
    if (settings.autoCollapseTimeout > 0) {
        collapseInterval = setInterval(async () => {
            const timeoutMs = settings.autoCollapseTimeout * 1000;
            if (timeoutMs <= 0) return;
            try {
                const windows = await browser.windows.getAll({ windowTypes: ['normal'] });
                const now = Date.now();
                for (const window of windows) {
                    const activeTabs = await browser.tabs.query({ active: true, windowId: window.id });
                    const activeTabInWindow = activeTabs.length > 0 ? activeTabs[0] : null;
                    const groups = await browser.tabGroups.query({ windowId: window.id, collapsed: false });
                    for (const group of groups) {
                        if (activeTabInWindow && activeTabInWindow.groupId === group.id) {
                             groupActivity.set(group.id, now);
                             continue;
                        }
                        const lastActivityTime = groupActivity.get(group.id) || Date.now();
                        if (now - lastActivityTime > timeoutMs) {
                            Logger.debug('checkAutoCollapse', `Grupo inativo ${group.id} a ser recolhido.`);
                            await browser.tabGroups.update(group.id, { collapsed: true });
                            groupActivity.delete(group.id);
                        }
                    }
                }
            } catch (e) { Logger.error("checkAutoCollapse", "Erro ao verificar grupos inativos:", e); }
        }, 5000);
    }
}

async function checkSingleTabGroups() {
    if (!settings.ungroupSingleTabs || settings.ungroupSingleTabsTimeout <= 0) return;
    const timeoutMs = settings.ungroupSingleTabsTimeout * 1000;
    const now = Date.now();

    try {
        const allTabs = await browser.tabs.query({});
        const groupInfo = new Map();

        for (const tab of allTabs) {
            if (tab.groupId && tab.groupId !== browser.tabs.TAB_ID_NONE) {
                if (!groupInfo.has(tab.groupId)) {
                    groupInfo.set(tab.groupId, { count: 0, tabId: null });
                }
                const info = groupInfo.get(tab.groupId);
                info.count++;
                info.tabId = tab.id;
            }
        }

        for (const [groupId, info] of groupInfo.entries()) {
            if (info.count === 1) {
                if (settings.manualGroupIds.includes(groupId)) continue;

                if (!singleTabGroupTimestamps.has(groupId)) {
                    singleTabGroupTimestamps.set(groupId, now);
                } else {
                    const timeEnteredState = singleTabGroupTimestamps.get(groupId);
                    if (now - timeEnteredState > timeoutMs) {
                        Logger.debug('checkSingleTabGroups', `Grupo ${groupId} solitário há ${now - timeEnteredState}ms. A desagrupar a aba ${info.tabId}.`);
                        await browser.tabs.ungroup([info.tabId]);
                        singleTabGroupTimestamps.delete(groupId);
                    }
                }
            } else {
                if (singleTabGroupTimestamps.has(groupId)) {
                    singleTabGroupTimestamps.delete(groupId);
                }
            }
        }
        
        for (const groupId of singleTabGroupTimestamps.keys()) {
            if (!groupInfo.has(groupId)) {
                singleTabGroupTimestamps.delete(groupId);
            }
        }

    } catch (e) {
        Logger.error("checkSingleTabGroups", "Erro ao verificar grupos com abas únicas:", e);
    }
}


function updateUngroupTimer() {
    Logger.debug('Timers', `Timer de desagrupar abas únicas ${settings.ungroupSingleTabs ? `ativado (${settings.ungroupSingleTabsTimeout}s)`: 'desativado'}.`);
    if (ungroupInterval) clearInterval(ungroupInterval);
    ungroupInterval = null;
    if (settings.ungroupSingleTabs && settings.ungroupSingleTabsTimeout > 0) {
        ungroupInterval = setInterval(checkSingleTabGroups, 1500);
    }
}

async function handleTabActivated({ tabId }) {
  if (!settings.uncollapseOnActivate) return;
  try {
    const tab = await browser.tabs.get(tabId);
    if (tab.groupId && tab.groupId !== browser.tabs.TAB_ID_NONE) {
      const groupId = tab.groupId;
      const now = Date.now();
      groupActivity.set(groupId, now);
      const group = await browser.tabGroups.get(groupId);
      if (group && group.collapsed) {
        Logger.debug('handleTabActivated', `A expandir o grupo ${groupId} devido à ativação da aba ${tabId}.`);
        await browser.tabGroups.update(groupId, { collapsed: false });
      }
    }
  } catch (error) { /* Silencioso, a aba pode ter sido fechada */ }
}


// --- Lógica de Contagem e Títulos dos Grupos ---

async function updateGroupTitleWithCount(groupId) {
    if (!settings.showTabCount || !groupId || groupId === browser.tabs.TAB_ID_NONE) return;
    try {
        const group = await browser.tabGroups.get(groupId);
        const tabsInGroup = await browser.tabs.query({ groupId: groupId });
        const count = tabsInGroup.length;
        
        let cleanTitle = (group.title || '').replace(/\s\(\d+\)$/, '').replace(/📌\s*/g, '');
        let newTitle = count > 0 ? `${cleanTitle} (${count})` : cleanTitle;

        if (settings.manualGroupIds.includes(groupId)) {
            newTitle = `📌 ${newTitle}`;
        }

        if (group.title !== newTitle) {
            Logger.debug('updateGroupTitle', `A atualizar o título do grupo ${groupId} para '${newTitle}'.`);
            await browser.tabGroups.update(groupId, { title: newTitle });
        }
    } catch (e) {
        if (!e.message.includes("No group with id")) {
            Logger.warn(`updateGroupTitle`, `Falha ao atualizar o título para o grupo ${groupId}:`, e);
        }
    }
}

function scheduleTitleUpdate(groupId) {
    if (!groupId || groupId === browser.tabs.TAB_ID_NONE) return;
    if (debouncedTitleUpdaters.has(groupId)) {
        clearTimeout(debouncedTitleUpdaters.get(groupId));
    }
    const timeoutId = setTimeout(() => {
        updateGroupTitleWithCount(groupId);
        debouncedTitleUpdaters.delete(groupId);
    }, TITLE_UPDATE_DEBOUNCE);
    debouncedTitleUpdaters.set(groupId, timeoutId);
}

// --- Lógica de Grupos Manuais e Edição de Regras ---

async function handleTabGroupCreated(group) {
    Logger.info('handleTabGroupCreated', `Grupo ${group.id} criado, a aguardar classificação.`, group);
    pendingClassificationGroups.add(group.id);
    
    setTimeout(async () => {
        if (recentlyCreatedAutomaticGroups.has(group.id)) {
            recentlyCreatedAutomaticGroups.delete(group.id);
            pendingClassificationGroups.delete(group.id);
            Logger.debug('handleTabGroupCreated', `Grupo ${group.id} classificado como automático.`);
            return;
        }
        
        if (pendingClassificationGroups.has(group.id)) {
            pendingClassificationGroups.delete(group.id);
            Logger.info('handleTabGroupCreated', `Grupo ${group.id} classificado como manual.`);
            if (!settings.manualGroupIds.includes(group.id)) {
                const newManualIds = [...settings.manualGroupIds, group.id];
                await updateSettings({ manualGroupIds: newManualIds });
                
                try {
                    const currentGroup = await browser.tabGroups.get(group.id);
                    const cleanTitle = (currentGroup.title || 'Grupo').replace(/📌\s*/g, '');
                    await browser.tabGroups.update(group.id, { title: `📌 ${cleanTitle}` });
                } catch (e) { /* O grupo pode já não existir */ }
            }
        }
    }, CLASSIFICATION_TIMEOUT);
}

async function handleTabGroupUpdated(group) {
    Logger.debug('handleTabGroupUpdated', `Grupo ${group.id} atualizado.`, group);
    const isManual = settings.manualGroupIds.includes(group.id);
    const title = group.title || '';
    const hasPin = title.startsWith('📌 ');

    if (isManual && !hasPin) {
        await browser.tabGroups.update(group.id, { title: `📌 ${title}` });
    } else if (!isManual && hasPin) {
        await browser.tabGroups.update(group.id, { title: title.replace(/📌\s*/g, '') });
    }
}

async function handleTabGroupRemoved(group) {
    Logger.info('handleTabGroupRemoved', `Grupo ${group.id} removido.`, group);
    pendingClassificationGroups.delete(group.id);
    recentlyCreatedAutomaticGroups.delete(group.id);
    if (settings.manualGroupIds.includes(group.id)) {
        const newManualIds = settings.manualGroupIds.filter(id => id !== group.id);
        await updateSettings({ manualGroupIds: newManualIds });
    }
}

async function checkForRenamedOrEditedRules(oldSettings, newSettings) {
    const oldRules = oldSettings.customRules || [];
    const newRules = newSettings.customRules || [];
    const changedRules = [];

    for (let i = 0; i < oldRules.length; i++) {
        if (newRules[i] && (oldRules[i].name !== newRules[i].name || oldRules[i].color !== newRules[i].color)) {
            changedRules.push({ oldName: oldRules[i].name, newName: newRules[i].name, newColor: newRules[i].color });
        }
    }
    
    if (changedRules.length === 0) return;
    Logger.info('checkForRenamedRules', 'Regras renomeadas ou editadas detetadas, a atualizar grupos existentes...', changedRules);

    const allGroups = await browser.tabGroups.query({});
    for (const change of changedRules) {
        const targetGroup = allGroups.find(g => (g.title || '').replace(/\s\(\d+\)$/, '').replace(/📌\s*/g, '') === change.oldName);

        if (targetGroup) {
            try {
                const updatePayload = {};
                if (change.oldName !== change.newName) updatePayload.title = (targetGroup.title || '').replace(change.oldName, change.newName);
                if (change.newColor && targetGroup.color !== change.newColor) updatePayload.color = change.newColor;
                if (Object.keys(updatePayload).length > 0) await browser.tabGroups.update(targetGroup.id, updatePayload);
            } catch (e) {
                Logger.error('checkForRenamedRules', `Erro ao atualizar o grupo para a regra renomeada de "${change.oldName}":`, e);
            }
        }
    }
}

// --- Gestor de Mensagens e Inicialização ---

browser.runtime.onMessage.addListener((message, sender, sendResponse) => {
    (async () => {
        Logger.info('onMessage', `Ação '${message.action}' recebida.`, message);
        try {
            switch (message.action) {
                case 'getSettings':
                    sendResponse(settings);
                    break;
                case 'updateSettings':
                    const { oldSettings, newSettings } = await updateSettings(message.settings);
                    Logger.setLevel(newSettings.logLevel); // Atualiza o nível do logger
                    
                    await checkForRenamedOrEditedRules(oldSettings, newSettings);
                    
                    if ((oldSettings.autoGroupingEnabled || oldSettings.showTabCount) !== (newSettings.autoGroupingEnabled || newSettings.showTabCount)) {
                        toggleListeners(newSettings.autoGroupingEnabled || newSettings.showTabCount);
                    }
                    
                    if (newSettings.autoCollapseTimeout !== oldSettings.autoCollapseTimeout) updateAutoCollapseTimer();
                    if (newSettings.ungroupSingleTabs !== oldSettings.ungroupSingleTabs || newSettings.ungroupSingleTabsTimeout !== oldSettings.ungroupSingleTabsTimeout) {
                        updateUngroupTimer();
                    }
                    await updateContextMenus();
                    sendResponse(newSettings);
                    break;
                case 'groupAllTabs':
                    await processTabQueue((await browser.tabs.query({ currentWindow: true, pinned: false })).map(t => t.id));
                    sendResponse({ status: "ok" });
                    break;
                // NOVO: Case para receber logs de outros scripts
                case 'log':
                    if (sender.tab && message.level && message.context && message.message) {
                        Logger[message.level](`ContentScript: ${message.context}`, message.message, ...(message.details || []));
                    }
                    break;
                default:
                    Logger.warn('onMessage', `Ação desconhecida recebida: ${message.action}`);
                    sendResponse({ error: `Ação desconhecida: ${message.action}` });
                    break;
            }
        } catch (error) {
            Logger.error('onMessage', `Erro ao processar a ação "${message.action}":`, error);
            sendResponse({ error: error.message });
        }
    })();
    return true;
});

async function populateTabGroupMap() {
    tabGroupMap.clear();
    try {
        const allTabs = await browser.tabs.query({});
        for (const tab of allTabs) {
            tabGroupMap.set(tab.id, tab.groupId);
        }
    } catch (e) {
        Logger.error("populateTabGroupMap", "Erro ao popular o mapa de Aba-Grupo:", e);
    }
}

async function main() {
    try {
        Logger.info('Main', 'Extensão a inicializar...');
        await loadSettings();
        Logger.setLevel(settings.logLevel);
        
        await populateTabGroupMap();
        
        if (settings.showTabCount) {
             const allGroups = await browser.tabGroups.query({});
             const titleUpdatePromises = allGroups.map(group => updateGroupTitleWithCount(group.id));
             await Promise.allSettled(titleUpdatePromises);
        }

        browser.tabs.onActivated.addListener(handleTabActivated);
        
        browser.tabGroups.onCreated.addListener(handleTabGroupCreated);
        browser.tabGroups.onUpdated.addListener(handleTabGroupUpdated);
        browser.tabGroups.onRemoved.addListener(handleTabGroupRemoved);
        
        initializeContextMenus();
        await updateContextMenus();

        toggleListeners(settings.autoGroupingEnabled || settings.showTabCount);
        updateAutoCollapseTimer();
        updateUngroupTimer();
        
        Logger.info("Main", "Auto Tab Grouper inicializado com sucesso.", { settings });
    } catch (e) {
        Logger.error("Main", "Falha crítica durante a inicialização da extensão:", e);
    }
}

main();
